# Simple KV storage with auth

Система поддерживает регистрацию, аутентификацию и авторизацию пользователей key-value хранилища. Хранилище для простоты умеет только хранить в памяти строковые ключи и значения, но с одним нюансом. Пространство ключей общее для всех пользователей, но пользователь может прочитать или перезаписать только свои ключи - те, которые он создал первым. Соответственно необходимо уметь идентифицировать пользователей и проверять их права доступа к ключам.

Регистрация и аутентификация пользователей реализована через отдельный сервис auth, который хранит учетные данные и выдает пользователям токены для доступа к хранилищу. В свою очередь, сервис хранилища валидирует токен из запроса пользователя и проверять права на выполнение запрашиваемой операции.

Для доступа пользователей к сервисам будем использовать HTTP. Для генерации токенов доступа используем стандарт [JSON Web Token](https://ru.wikipedia.org/wiki/JSON_Web_Token) (JWT).

Для упрощения все данные будем хранить в памяти используя хеш-таблицы.

## Интерфейсы

Опишем интерфейсы наших сервисов. На каждый запрос есть curl-пример в [examples.md](./examples.md).

### Сервис аутентификации

Сервис выполняет функции регистрации новых пользователей, аутентификации по логину/паролю и проверки существующего токена. Соответственно, сервис имеет три HTTP хэндлера: `/signup`, `/login`, `/whoami`.

Сервис написан на С++ фреймворк [userver](https://userver.tech/) с использованием синтаксиса для быстрого прототипирования [easy library](https://userver.tech/da/de8/md_en_2userver_2libraries_2easy.html).

#### Регистрация

```
POST /signup
body: { "username": "kek", "password": "kekpassword" }
```

Статусы ответа:
- 200 если новый пользователь успешно зарегистрирован, в этом случае в заголовке `Set-Cookie` будет передан (как [кука](https://ru.wikipedia.org/wiki/Cookie)) токен, который надо использовать при доступе к хранилищу.
- 403 если пользователь с таким именем уже существует.

#### Аутентификация

```
POST /login
body: { "username": "kek", "password": "kekpassword" }
```

Статусы ответа:
- 200 если аутентификация прошла успешно, в этом случае в заголовке `Set-Cookie` будет передан токен, который надо использовать при доступе к хранилищу.
- 403 если пользователя не существует или передан неверный пароль.

#### Проверка токена

```
GET /whoami
Cookie: jwt=...
```

Статусы ответа:
- 200 если токен из куки валидный, тогда в теле ответа передается `Hello, {username}`.
- 401 если заголовок Cookie отсутствует.
- 400 если токен не валидный (мусор или подписана другой подписью).

### Key-value хранилище

Хранилище поддерживает операции записи и чтения значений по ключу. При этом проверяется право пользователя на выполнении операции с данным ключом. Далее будем считать, что ключ принадлежит пользователю, если он был создан этим пользователем.

Key-value хранилище разработано на Python с использованием Flask.

#### Запись значения ключа

```
POST /put?key=kek
Cookie: jwt=...
body: { "value": "lol" }
```

Статусы ответа:
- 200 если запись успешна (ключа не было изначально, либо он принадлежит пользователю).
- 403 если ключ существует, но принадлежит другому пользователю.
- 401 если куки с токеном нет.
- 400 если токен не валидный.

#### Чтение значения ключа

```
GET /get?key=kek
Cookie: jwt=...
```

Статусы ответа:
- 200 если ключ есть и принадлежит пользователю, тогда в теле ответа передается `{"value": "lol"}`.
- 403 если ключ существует, но принадлежит другому пользователю.
- 404 если ключа не существует.
- 401 если куки с токеном нет.
- 400 если токен не валидный.

## Требования к реализации

В качестве разновидности токенов используется JWT с парой RSA ключей (приватный и публичный). Для запуска вам необходимо сгенерировать пару ключей самим с помощью OpenSSL и положить их в папку `auth`: приватный `signature.pem` и публичный `signature.pub` (на самом деле можете положить куда угодно, главное поправьте `docker-compose.yml`).

## Запуск тестов

Тесты написаны как тесты черных ящиков — они делают только HTTP запросы и проверяют, что ответы соответствуют ожидаемому поведению. Кроме того, в тесты необходимо передать свою пару ключей.

Чтобы локально запустить тесты, необходимо передать им несколько переменных окружения:

```
сd tests
export JWT_PRIVATE_KEY_FILE=../auth/signature.pem
export JWT_PUBLIC_KEY_FILE=../auth/signature.pub
export AUTH_SERVER_URL="http://localhost:8090"
export KV_SERVER_URL="http://localhost:8091"

pytest -vs [-k <класс с группой тестов>]
```

Чтобы запустить тесты с помощью docker compose достаточно вызвать сборку и запуск одной командой:

```
docker compose up --build tests
```
